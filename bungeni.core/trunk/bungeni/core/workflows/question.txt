Question workflow
=================

  >>> from bungeni.core.domain import Question

Setup
-----

  >>> import bungeni.core.workflows.question
  >>> import bungeni.core.interfaces
  >>> import ore.workflow
  >>> import copy
  
  >>> component.provideAdapter(
  ...    bungeni.core.workflows.WorkflowState,
  ...    (bungeni.core.interfaces.IBungeniContent,))

  >>> component.provideAdapter(
  ...    bungeni.core.workflows.question.QuestionWorkflowAdapter,
  ...    (Question,))

  >>> component.provideAdapter(
  ...    ore.workflow.workflow.WorkflowInfo,
  ...    (Question,))

  >>> component.provideHandler(
  ...    bungeni.core.workflows.question.workflowTransitionEventDispatcher)

  >>> import bungeni.core.version
  >>> component.provideAdapter(
  ...    bungeni.core.version.ContextVersioned,
  ...    (bungeni.core.interfaces.IVersionable,),
  ...    bungeni.core.interfaces.IVersioned)
  
Transition events
-----------------

We set up event subscribers to make sure all registered transition
events are called.

  >>> map = bungeni.core.workflows.question.workflow_transition_event_map
  >>> check_transition_events = dict((states, False) for states in map.keys())

  >>> for states, iface in map.items():
  ...     def generate(key):
  ...         def handler(event):
  ...             check_transition_events[key] = True
  ...         return handler
  ...     component.provideHandler(generate(states), adapts=(iface,))
  
Workflow
--------

  >>> from ore.workflow.interfaces import IWorkflow, IWorkflowInfo

  >>> def transitions(question):
  ...     wf = IWorkflow(question)
  ...     info = IWorkflowInfo(question)
  ...     state = info.state().getState()
  ...     return tuple(transition.transition_id for transition in wf.getTransitions(state))


Permissions
-----------
  >>> def permission(question):
  ...   wf = IWorkflow(question)
  ...   info = IWorkflowInfo(question)
  ...   state = info.state().getState()
  ...   return tuple(transition.permission for transition in wf.getTransitions(state))



  >>> question = Question()

First we initialize the workflow.
  
  >>> transitions(question)
  ('create',)

  >>> permission(question)
  (Global(CheckerPublic,zope.security.checker),)

  >>> IWorkflowInfo(question).fireTransition('create')

The question is now in a draft state.

  >>> transitions(question)
   ('make-private', 'submit-to-clerk')
    
  >>> permission(question)
  ('bungeni.question.Submit', 'bungeni.question.Submit')

The Question can be made a private draft

  >>> result = IWorkflowInfo(question).fireTransition('make-private')
  
  >>> transitions(question)
  ('re-draft',)  

and can be put into draft state at a later time

  >>> result = IWorkflowInfo(question).fireTransition('re-draft')
  
  >>> transitions(question)
   ('make-private', 'submit-to-clerk')


When we submit the question, a new version is created.
  
  >>> result = IWorkflowInfo(question).fireTransition('submit-to-clerk')

The transition action returns None, indicating that the the current
instance is still active.

  >>> result is None
  True

Verify that a new version was issued.

  >>> from bungeni.core.interfaces import IVersioned
  >>> versions = IVersioned(question)
  >>> len(list(versions.values()))
  1

Let's examine the version.

  >>> version = list(versions.values())[0]
  >>> version.status
  u'draft question'

Submitted:

  >>> transitions(question)
  ('withdraw-submitted', 'received-by-clerk')

A question can be withdrawn at (almost) any stage  
  
  >>> question_withdraw = copy.deepcopy(question)
  >>> result = IWorkflowInfo(question_withdraw).fireTransition('withdraw-submitted')   

  >>> question_withdraw.status
  u'Question withdrawn'  

  >>> IWorkflowInfo(question).fireTransition('received-by-clerk')


Received:

  >>> transitions(question)
  ('require-edit-by-mp', 'complete', 'withdraw-received')

A question can be withdrawn at (almost) any stage  
  
  >>> question_withdraw = copy.deepcopy(question)
  >>> result = IWorkflowInfo(question_withdraw).fireTransition('withdraw-received')   

  >>> question_withdraw.status
  u'Question withdrawn'  
  
  

  
If it needs clarification this sets it back to draft and it must be submitted again  
  
  >>> result = IWorkflowInfo(question).fireTransition('require-edit-by-mp')
  

  >>> transitions(question)
  ('resubmit-clerk', 'withdraw-amend')

    
  >>> result = IWorkflowInfo(question).fireTransition('resubmit-clerk')
  
versioned again
  
  >>> len(list(versions.values()))
  2    
    
  >>> IWorkflowInfo(question).fireTransition('received-by-clerk')
    
complete the question

  >>> result = IWorkflowInfo(question).fireTransition('complete')  
    
  
The speakers office now has to review the question

  >>> transitions(question)
  ('withdraw-complete', 'approve', 'require-amendment', 'reject')

A question can be withdrawn at (almost) any stage  
  
  >>> question_withdraw = copy.deepcopy(question)
  >>> result = IWorkflowInfo(question_withdraw).fireTransition('withdraw-complete')   

  >>> question_withdraw.status
  u'Question withdrawn'


Reject the question

  >>> question_reject = copy.deepcopy(question)
  >>> transitions(question_reject)
  ('withdraw-complete', 'approve', 'require-amendment', 'reject')

  >>> result = IWorkflowInfo(question_reject).fireTransition('reject') 

  >>> transitions(question_reject)
  ()     

If the questions requires amendment it is sent back to the owner
and has to be resubmitted 

  >>> transitions(question)
  ('withdraw-complete', 'approve', 'require-amendment', 'reject')

  >>> question_amend = copy.deepcopy(question)
  >>> result = IWorkflowInfo(question_amend).fireTransition('require-amendment')   
  
it gets versioned before amendment
  >>> len(list(versions.values()))
  3  
  
  >>> transitions(question_amend)
  ('complete-clarify', 'mp-clarify')

The clerks office can resubmit the question

  >>> question_clerk_resubmit = copy.deepcopy(question_amend)
  >>> result = IWorkflowInfo(question_clerk_resubmit).fireTransition('complete-clarify')    
  >>> transitions(question_clerk_resubmit)
  ('withdraw-complete', 'approve', 'require-amendment', 'reject')


or the question can be send back to the mp for further clarification

  >>> result = IWorkflowInfo(question_amend).fireTransition('mp-clarify')  
  >>> transitions(question_amend)
  ('resubmit-clerk', 'withdraw-amend')





A question can be withdrawn at (almost) any stage  
  
  >>> question_withdraw = copy.deepcopy(question_amend)
  >>> result = IWorkflowInfo(question_withdraw).fireTransition('withdraw-amend')   

  >>> question_withdraw.status
  u'Question withdrawn'


  >>> result = IWorkflowInfo(question_amend).fireTransition('resubmit-clerk')  

it gets versioned by resubmitting after amendment
  >>> len(list(versions.values()))
  4

  >>> transitions(question_amend)   
  ('withdraw-submitted', 'received-by-clerk')

clerks recieves it

  >>> result = IWorkflowInfo(question_amend).fireTransition('received-by-clerk')  


  
Appove the question

  >>> transitions(question)
  ('withdraw-complete', 'approve', 'require-amendment', 'reject')

  >>> result = IWorkflowInfo(question).fireTransition('approve')  
  
  >>> transitions(question)
  ('defer', 'withdraw-admissible', 'send-ministry', 'schedule')

A question can be withdrawn at (almost) any stage  
  
  >>> question_withdraw = copy.deepcopy(question)
  >>> result = IWorkflowInfo(question_withdraw).fireTransition('withdraw-admissible')   

  >>> question_withdraw.status
  u'Question withdrawn'


A written response to the question

  >>> question_written_response = copy.deepcopy(question)


  >>> result = IWorkflowInfo(question_written_response).fireTransition('send-ministry')  
  
  >>> transitions(question_written_response)
   ('elapse-pending', 'respond-writing')

A question can elapse if no answer is given

  >>> question_written_response_elapse = copy.deepcopy(question_written_response)


  >>> result = IWorkflowInfo(question_written_response_elapse).fireTransition('elapse-pending')  
  
  >>> transitions(question_written_response_elapse)
   ()

Or the question can be responded to in writing

  >>> result = IWorkflowInfo(question_written_response).fireTransition('respond-writing')  
  
  >>> transitions(question_written_response)
  ('answer',)  

defer the question

  >>> question_defer = copy.deepcopy(question)
  >>> result = IWorkflowInfo(question_defer).fireTransition('defer')   
  
  >>> transitions(question_defer)     
  ('schedule-deferred', 'elapse-defered', 'defer-ministry', 'withdraw-deferred')
  
A deferred question can be assigned to a ministry for a written response

  >>> question_defer_response = copy.deepcopy(question_defer)


  >>> result = IWorkflowInfo(question_defer_response).fireTransition('defer-ministry')  
  
  >>> transitions(question_defer_response)
  ('elapse-pending', 'respond-writing')

  >>> result = IWorkflowInfo(question_defer_response).fireTransition('respond-writing')  
  
  >>> transitions(question_defer_response)
  ('answer',)  
  
  
A queston can elapse if no answer is given
  >>> question_elapse_defered = copy.deepcopy(question_defer)
  
  >>> result = IWorkflowInfo(question_elapse_defered).fireTransition('elapse-defered')    
  >>> transitions(question_elapse_defered)
  ()

A question can be withdrawn at (almost) any stage  
  
  >>> question_withdraw = copy.deepcopy(question_defer)
  >>> result = IWorkflowInfo(question_withdraw).fireTransition('withdraw-deferred')   

  >>> question_withdraw.status
  u'Question withdrawn'  

  >>> result = IWorkflowInfo(question_defer).fireTransition('schedule-deferred')   
  >>> transitions(question_defer)     
  ('postpone', 'withdraw-scheduled', 'respond-sitting')

schedule the question

  >>> result = IWorkflowInfo(question).fireTransition('schedule')  
  
  >>> transitions(question)
  ('postpone', 'withdraw-scheduled', 'respond-sitting')

A question can be withdrawn at (almost) any stage  
  
  >>> question_withdraw = copy.deepcopy(question)
  >>> result = IWorkflowInfo(question_withdraw).fireTransition('withdraw-scheduled')   

  >>> question_withdraw.status
  u'Question withdrawn'

postpone the question
  
  >>> result = IWorkflowInfo(question).fireTransition('postpone')  
  >>> transitions(question)
  ('schedule-postponed', 'elapse-postponed', 'postponed-ministry', 'withdraw-postponed')
 
A question can elapse without an answer 

  >>> question_elapse_postponed = copy.deepcopy(question)
  >>> result = IWorkflowInfo(question_elapse_postponed).fireTransition('elapse-postponed')   
  >>> transitions(question_elapse_postponed)
  ()
  
A question can be withdrawn at (almost) any stage  
  
  >>> question_withdraw = copy.deepcopy(question)
  >>> result = IWorkflowInfo(question_withdraw).fireTransition('withdraw-postponed')   

  >>> question_withdraw.status
  u'Question withdrawn'

and reschedule it

  >>> result = IWorkflowInfo(question).fireTransition('schedule-postponed')  
  
  >>> transitions(question)
  ('postpone', 'withdraw-scheduled', 'respond-sitting')


respond to the question

  >>> result = IWorkflowInfo(question).fireTransition('respond-sitting')  
  >>> transitions(question)
  ('answer',)

the question gets marked as answered

 >>> result = IWorkflowInfo(question).fireTransition('answer')  
  >>> transitions(question)
  ()      

  
Transition events check
-----------------------

  >>> print check_transition_events
  {(u'draft question', u'Question submitted to clerk'): True, 
   (u'Question submitted to clerk', u'Question received by clerk'): True}




